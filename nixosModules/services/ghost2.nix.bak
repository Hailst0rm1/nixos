{
  options,
  lib,
  config,
  pkgs,
  ...
}: let
  # domain for the Ghost blog
  serverName = "pontonsecurity.com";
  # port on which the Ghost service runs
  port = "1357";
  # user used to run the Ghost service
  userName = builtins.replaceStrings ["."] ["_"] serverName;
  # MySQL database used by Ghost
  dbName = userName;
  # MySQL user used by Ghost
  dbUser = userName;
  # directory used to save the blog content
  dataDir = "/var/lib/${userName}";
  # Ghost package we created in the section above
  ghost = import ../../pkgs/ghost {inherit pkgs;};
  # script that sets up the Ghost content directory
  setupScript = pkgs.writeScript "${serverName}-setup.sh" ''
    #! ${pkgs.stdenv.shell} -e
    chmod g+s "${dataDir}"
    [[ ! -d "${dataDir}/content" ]] && cp -r "${ghost}/content" "${dataDir}/content"
    chown -R "${userName}":"${userName}" "${dataDir}/content"
    chmod -R +w "${dataDir}/content"
    ln -f -s "/etc/${serverName}.json" "${dataDir}/config.production.json"
    [[ -d "${dataDir}/current" ]] && rm "${dataDir}/current"
    ln -f -s "${ghost}/current" "${dataDir}/current"
    [[ -d "${dataDir}/content/themes/casper" ]] && rm "${dataDir}/content/themes/casper"
    ln -f -s "${ghost}/current/content/themes/casper" "${dataDir}/content/themes/casper"
  '';

  databaseService = "mysql.service";
in {
  options.services.ghost = {
    enable = lib.mkEnableOption "Enable ghost blog service.";

    domain = lib.mkOption {
      type = lib.types.str;
      default = "";
      description = "Domain user for ghost, e.g. example.com";
    };

    sslCertPath = lib.mkOption {
      type = lib.types.str;
      description = "The ssl cert.pem file path.";
    };

    sslCertKeyPath = lib.mkOption {
      type = lib.types.str;
      description = "The ssl private key cert.key file path.";
    };
  };

  config = lib.mkIf config.services.ghost.enable {
    # Creates the user and group
    users.users.${userName} = {
      isSystemUser = true;
      group = userName;
      createHome = true;
      home = dataDir;
    };
    users.groups.${userName} = {};

    # Creates the Ghost config
    environment.etc."${serverName}.json".text = ''
      {
        "url": "https://${serverName}",
        "server": {
          "port": ${port},
          "host": "0.0.0.0"
        },
        "database": {
          "client": "mysql",
          "connection": {
            "host": "localhost",
            "user": "${dbUser}",
            "database": "${dbName}",
            "password": "",
            "socketPath": "/run/mysqld/mysqld.sock"
          }
        },
        "mail": {
          "transport": "sendmail"
        },
        "logging": {
          "transports": ["stdout"]
        },
        "paths": {
          "contentPath": "${dataDir}/content"
        }
      }
    '';

    # Sets up the Systemd service
    systemd.services."${serverName}" = {
      enable = true;
      description = "${serverName} ghost blog";
      restartIfChanged = true;
      restartTriggers = [ghost config.environment.etc."${serverName}.json".source];
      requires = [databaseService];
      after = [databaseService];
      path = [pkgs.nodejs pkgs.vips];
      wantedBy = ["multi-user.target"];
      serviceConfig = {
        User = userName;
        Group = userName;
        WorkingDirectory = dataDir;
        # Executes the setup script before start
        ExecStartPre = setupScript;
        # Runs Ghost with node
        ExecStart = "${pkgs.nodejs}/bin/node current/index.js";
        # Sandboxes the Systemd service
        AmbientCapabilities = [];
        CapabilityBoundingSet = [];
        KeyringMode = "private";
        LockPersonality = true;
        NoNewPrivileges = true;
        PrivateDevices = true;
        PrivateMounts = true;
        PrivateTmp = true;
        ProtectClock = true;
        ProtectControlGroups = true;
        ProtectHome = true;
        ProtectHostname = true;
        ProtectKernelLogs = true;
        ProtectKernelModules = true;
        ProtectKernelTunables = true;
        ProtectSystem = "full";
        RemoveIPC = true;
        RestrictAddressFamilies = [];
        RestrictNamespaces = true;
        RestrictRealtime = true;
      };
      environment = {NODE_ENV = "production";};
    };
    services.nginx = {
      enable = true;
      # recommendedGzipSettings = true;
      # recommendedOptimisation = true;
      # recommendedProxySettings = true;
      # recommendedTlsSettings = true;
      virtualHosts."${serverName}" = {
        enableACME = false;
        forceSSL = true;
        http2 = true;

        sslCertificate = config.services.ghost.sslCertPath;
        sslCertificateKey = config.services.ghost.sslCertKeyPath;

        root = "${dataDir}/system/nginx-root";

        extraConfig = ''
          client_max_body_size 100m;
        '';

        locations."/" = {
          proxyPass = "http://127.0.0.1:${port}";
          extraConfig = ''
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Host $host;

            if ($request_method = 'OPTIONS') {
              add_header 'Access-Control-Allow-Origin' '*' always;
              add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
              add_header 'Access-Control-Allow-Headers' 'Accept-Version,Credentials,Authorization,DNT,Mode,User-Agent,x-ghost-preview,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';
              add_header 'Access-Control-Max-Age' 1728000;
              add_header 'Content-Type' 'text/plain; charset=utf-8';
              add_header 'Content-Length' 0;
              return 204;
            }
            if ($request_method = 'POST') {
              add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
              add_header 'Access-Control-Allow-Headers' 'Authorization,Credentials,DNT,Mode,User-Agent,x-ghost-preview,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range' always;
              add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range' always;
            }
            if ($request_method = 'GET') {
              add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
              add_header 'Access-Control-Allow-Headers' 'Authorization,Credentials,DNT,Mode,User-Agent,X-Requested-With,x-ghost-preview,If-Modified-Since,Cache-Control,Content-Type,Range' always;
              add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range' always;
            }
            if ($http_origin = "app://obsidian.md") {
              add_header 'Access-Control-Allow-Origin' '*' always;
            }
          '';
        };

        locations."~ /.well-known" = {
          extraConfig = "allow all;";
        };
      };
    };

    # # Sets up the blog virtual host on NGINX
    # services.nginx = {
    #   enable = true;
    #   # recommendedGzipSettings = true;
    #   # recommendedOptimisation = true;
    #   # recommendedProxySettings = true;
    #   # recommendedTlsSettings = true;
    #   virtualHosts.${serverName} = {
    #     # Sets up Lets Encrypt SSL certificates for the blog
    #     forceSSL = true;
    #     enableACME = false;
    #     locations."/" = {proxyPass = "http://127.0.0.1:${port}";};
    #     extraConfig = ''
    #       charset UTF-8;

    #       add_header Strict-Transport-Security "max-age=2592000; includeSubDomains" always;
    #       add_header Referrer-Policy "strict-origin-when-cross-origin";
    #       add_header X-Frame-Options "SAMEORIGIN";
    #       add_header X-XSS-Protection "1; mode=block";
    #       add_header X-Content-Type-Options nosniff;
    #     '';
    #   };
    # };

    # Sets up MySQL database and user for Ghost
    services.mysql = {
      enable = true;
      package = pkgs.mariadb;
      ensureDatabases = [dbName];
      ensureUsers = [
        {
          name = dbUser;
          ensurePermissions = {"${dbName}.*" = "ALL PRIVILEGES";};
        }
      ];
    };
  };
}
